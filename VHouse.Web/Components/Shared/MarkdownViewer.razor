@using VHouse.Web.Services
@inject IMarkdownService MarkdownService
@inject IJSRuntime JSRuntime

<div class="markdown-viewer">
    @if (IsLoading)
    {
        <div class="loading-state">
            <div class="spinner">üå±</div>
            <p>Cargando contenido...</p>
        </div>
    }
    else if (!string.IsNullOrEmpty(Content))
    {
        <div class="markdown-content" id="markdown-content">
            @((MarkupString)_renderedHtml)
        </div>
    }
    else
    {
        <div class="empty-state">
            <div class="empty-icon">üìÑ</div>
            <h3>Sin contenido</h3>
            <p>No hay contenido para mostrar en este momento.</p>
        </div>
    }
</div>

<style>
.markdown-viewer {
    width: 100%;
    min-height: 200px;
}

.loading-state {
    text-align: center;
    padding: var(--spacing-8);
}

.spinner {
    font-size: 3rem;
    animation: spin 2s linear infinite;
    display: block;
    margin-bottom: var(--spacing-4);
}

@@keyframes spin {
    from { transform: rotate(0deg); }
    to { transform: rotate(360deg); }
}

.markdown-content {
    line-height: 1.7;
    color: var(--text-primary);
}

.markdown-content h1,
.markdown-content h2,
.markdown-content h3,
.markdown-content h4,
.markdown-content h5,
.markdown-content h6 {
    color: var(--primary-green);
    margin-top: var(--spacing-6);
    margin-bottom: var(--spacing-4);
    font-weight: 600;
}

.markdown-content h1 {
    font-size: 2.5rem;
    border-bottom: 2px solid var(--primary-green);
    padding-bottom: var(--spacing-2);
}

.markdown-content h2 {
    font-size: 2rem;
    border-bottom: 1px solid var(--border-color);
    padding-bottom: var(--spacing-1);
}

.markdown-content h3 {
    font-size: 1.5rem;
}

.markdown-content h4 {
    font-size: 1.25rem;
}

.markdown-content p {
    margin-bottom: var(--spacing-4);
    line-height: 1.8;
}

.markdown-content ul,
.markdown-content ol {
    margin-bottom: var(--spacing-4);
    padding-left: var(--spacing-6);
}

.markdown-content li {
    margin-bottom: var(--spacing-2);
    line-height: 1.6;
}

.markdown-content strong {
    font-weight: 600;
    color: var(--text-primary);
}

.markdown-content em {
    font-style: italic;
    color: var(--text-secondary);
}

.markdown-content code {
    background: var(--surface-bg);
    padding: var(--spacing-1) var(--spacing-2);
    border-radius: var(--radius-sm);
    font-family: var(--font-mono);
    font-size: 0.9em;
    color: var(--accent-green);
    border: 1px solid var(--border-color);
}

.markdown-content pre {
    background: var(--surface-bg);
    padding: var(--spacing-4);
    border-radius: var(--radius-md);
    overflow-x: auto;
    margin-bottom: var(--spacing-4);
    border: 1px solid var(--border-color);
}

.markdown-content pre code {
    background: transparent;
    padding: 0;
    border: none;
    border-radius: 0;
}

.markdown-content blockquote {
    border-left: 4px solid var(--primary-green);
    margin: var(--spacing-4) 0;
    padding: var(--spacing-4);
    background: var(--surface-bg);
    border-radius: var(--radius-md);
}

.markdown-content blockquote p {
    margin: 0;
    font-style: italic;
    color: var(--text-secondary);
}

.markdown-content table {
    width: 100%;
    border-collapse: collapse;
    margin-bottom: var(--spacing-4);
    background: var(--card-bg);
    border-radius: var(--radius-md);
    overflow: hidden;
    box-shadow: var(--shadow-sm);
}

.markdown-content th,
.markdown-content td {
    padding: var(--spacing-3);
    text-align: left;
    border-bottom: 1px solid var(--border-color);
}

.markdown-content th {
    background: var(--primary-green);
    color: white;
    font-weight: 600;
}

.markdown-content tr:hover {
    background: var(--surface-bg);
}

.markdown-content img {
    max-width: 100%;
    height: auto;
    border-radius: var(--radius-md);
    margin: var(--spacing-4) 0;
    box-shadow: var(--shadow-sm);
}

.markdown-content a {
    color: var(--primary-green);
    text-decoration: none;
    font-weight: 500;
    border-bottom: 1px solid transparent;
    transition: all var(--transition-fast);
}

.markdown-content a:hover {
    border-bottom-color: var(--primary-green);
    color: var(--accent-green);
}

.mermaid-container {
    margin: var(--spacing-6) 0;
    padding: var(--spacing-4);
    background: var(--card-bg);
    border-radius: var(--radius-lg);
    border: 1px solid var(--border-color);
    overflow-x: auto;
}

.empty-state {
    text-align: center;
    padding: var(--spacing-8);
    color: var(--text-secondary);
}

.empty-icon {
    font-size: 4rem;
    margin-bottom: var(--spacing-4);
    opacity: 0.5;
}

.empty-state h3 {
    color: var(--text-primary);
    margin-bottom: var(--spacing-2);
}

.empty-state p {
    margin: 0;
    font-size: var(--font-size-sm);
}

/* Dark mode adjustments - CSS media query */
@@media (prefers-color-scheme: dark) {
    .markdown-content code {
        background: var(--gray-800);
    }
    
    .markdown-content pre {
        background: var(--gray-800);
    }
    
    .markdown-content blockquote {
        background: var(--gray-800);
    }
}
</style>

@code {
    private string _renderedHtml = string.Empty;
    private List<string> _mermaidDiagrams = new();
    
    [Parameter] public string Content { get; set; } = string.Empty;
    [Parameter] public bool IsLoading { get; set; } = false;
    [Parameter] public EventCallback<string> OnContentProcessed { get; set; }

    protected override async Task OnParametersSetAsync()
    {
        if (!string.IsNullOrEmpty(Content) && !IsLoading)
        {
            await ProcessContent();
        }
        else if (string.IsNullOrEmpty(Content))
        {
            _renderedHtml = string.Empty;
            _mermaidDiagrams.Clear();
        }
    }

    private async Task ProcessContent()
    {
        try
        {
            var (html, diagrams) = MarkdownService.ConvertWithMermaidExtraction(Content);
            _renderedHtml = html;
            _mermaidDiagrams = diagrams;

            // Mermaid diagrams are already embedded as <div class="mermaid"> in the HTML
            // No additional processing needed

            if (OnContentProcessed.HasDelegate)
            {
                await OnContentProcessed.InvokeAsync(_renderedHtml);
            }

            StateHasChanged();
        }
        catch (Exception ex)
        {
            _renderedHtml = $"<div class=\"error-state\"><h3>‚ùå Error al procesar contenido</h3><p>{ex.Message}</p></div>";
            _mermaidDiagrams.Clear();
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (!firstRender && _mermaidDiagrams.Count > 0)
        {
            try
            {
                // Initialize Mermaid diagrams after render - use native mermaid initialization
                await JSRuntime.InvokeVoidAsync("mermaid.run");
            }
            catch (Exception)
            {
                // Fallback to init if run is not available
                try
                {
                    await JSRuntime.InvokeVoidAsync("mermaid.init");
                }
                catch (Exception)
                {
                    // Mermaid initialization failed - continue without diagrams
                }
            }
        }
    }
}