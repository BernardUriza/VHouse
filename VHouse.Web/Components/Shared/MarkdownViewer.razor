@using VHouse.Web.Services
@inject IMarkdownService MarkdownService
@inject IJSRuntime JSRuntime

<div class="markdown-viewer">
    @if (IsLoading)
    {
        <div class="loading-state">
            <div class="spinner">üå±</div>
            <p>Cargando contenido...</p>
        </div>
    }
    else if (!string.IsNullOrEmpty(Content))
    {
        <div class="markdown-content" id="markdown-content">
            @((MarkupString)_renderedHtml)
        </div>
    }
    else
    {
        <div class="empty-state">
            <div class="empty-icon">üìÑ</div>
            <h3>Sin contenido</h3>
            <p>No hay contenido para mostrar en este momento.</p>
        </div>
    }
</div>

<style>
/* Base viewer styles only - typography handled by markdown-viewer.css */
.markdown-viewer {
    width: 100%;
    min-height: 200px;
}

.loading-state {
    text-align: center;
    padding: var(--spacing-8);
}

.spinner {
    font-size: 3rem;
    animation: spin 2s linear infinite;
    display: block;
    margin-bottom: var(--spacing-4);
}

@@keyframes spin {
    from { transform: rotate(0deg); }
    to { transform: rotate(360deg); }
}

.empty-state {
    text-align: center;
    padding: var(--spacing-8);
    color: var(--text-secondary);
}

.empty-icon {
    font-size: 4rem;
    margin-bottom: var(--spacing-4);
    opacity: 0.5;
}

.empty-state h3 {
    color: var(--text-primary);
    margin-bottom: var(--spacing-2);
}

.empty-state p {
    margin: 0;
    font-size: var(--font-size-sm);
}
</style>

@code {
    private string _renderedHtml = string.Empty;
    private List<string> _mermaidDiagrams = new();
    private string _previousContent = string.Empty;
    
    [Parameter] public string Content { get; set; } = string.Empty;
    [Parameter] public bool IsLoading { get; set; } = false;
    [Parameter] public EventCallback<string> OnContentProcessed { get; set; }

    protected override async Task OnParametersSetAsync()
    {
        // Check if content has actually changed
        if (Content != _previousContent)
        {
            _previousContent = Content;
            
            if (!string.IsNullOrEmpty(Content) && !IsLoading)
            {
                await ProcessContent();
            }
            else if (string.IsNullOrEmpty(Content))
            {
                _renderedHtml = string.Empty;
                _mermaidDiagrams.Clear();
            }
        }
    }

    private async Task ProcessContent()
    {
        try
        {
            var (html, diagrams) = MarkdownService.ConvertWithMermaidExtraction(Content);
            _renderedHtml = html;
            _mermaidDiagrams = diagrams;

            // Mermaid diagrams are already embedded as <div class="mermaid"> in the HTML
            // No additional processing needed

            if (OnContentProcessed.HasDelegate)
            {
                await OnContentProcessed.InvokeAsync(_renderedHtml);
            }

            StateHasChanged();
        }
        catch (Exception ex)
        {
            _renderedHtml = $"<div class=\"error-state\"><h3>‚ùå Error al procesar contenido</h3><p>{ex.Message}</p></div>";
            _mermaidDiagrams.Clear();
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (!firstRender)
        {
            try
            {
                // Initialize Mermaid diagrams if present
                if (_mermaidDiagrams.Count > 0)
                {
                    await JSRuntime.InvokeVoidAsync("mermaid.run");
                }
                
                // Initialize all markdown viewer enhancements
                await JSRuntime.InvokeVoidAsync("MarkdownViewer.init");
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error initializing markdown viewer: {ex.Message}");
            }
        }
    }
}